<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>backwater</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<h1>backwater</h1>


<p>[![Build Status](https://travis-ci.org/g-andrade/backwater.png?branch=master)](https://travis-ci.org/g-andrade/backwater)
[![Hex pm](http://img.shields.io/hexpm/v/backwater.svg?style=flat)](https://hex.pm/packages/backwater)</p>

<h5><a name="Backwater_-_an_RPC_framework_for_Erlang_and_Elixir">Backwater - an RPC framework for Erlang and Elixir</a></h5>

<p>Backwater aims to make execution of calls to modules/functions on individual remote machines as
close to local calls as they can get. The remote calls are executed over HTTP(S) and don't depend
on the Erlang distribution protocol nor on both ends being clustered.</p>

<p>Backwater is built on top of <a href="https://github.com/ninenines/cowboy">cowboy</a> and
<a href="https://github.com/benoitc/hackney">hackney</a>.</p>

<p><b>Jump directly to some <a href="#examples">quick examples</a></b> or to the <a href="#modules">function reference</a>.</p>

<p>Requirements:
* Erlang/OTP 19 and up
* rebar3</p>

<p>Features:
* Arbitrary modules can be wholly or partially exposed
* Module-specific wrappers for remote calls can be generated using a bundled rebar3 plugin (Erlang only)
* Functions to be exposed are, by default, specified using custom module attributes (Erlang) or a custom export function (Elixir)
* Arguments and return values are encoded using <a href="http://erlang.org/doc/apps/erts/erl_ext_dist">external term format</a>; if <a href="http://erlang.org/doc/man/erlang#binary_to_term-2">unsafe</a>, they're rejected by default
* Multiple instances of both client and server can be launched and managed independently
* Remote exceptions are returned as errors but can be locally rethrown if so desired
* (Purged) stacktraces of remote exceptions are returned by default
* All calls and responses are authenticated and signed using a modified version of <a href="https://tools.ietf.org/id/draft-cavage-http-signatures-07.txt">HTTP signatures</a>; nevertheless, it's <b>strongly</b> recommended to use HTTPS, as this doesn't protect against replay attacks (besides the potential exposure of sensitive data)</p>

<p>Details:
* The server start/stop interface is very similar to cowboy's, and all cowboy settings, excluding routing, are available for tweaking
* The client interface is made up of start/stop calls for management and an apply/3-esque function; hackney settings can be arbitrarily tweaked or overridden
* The rebar3 code generation plugin is still not as polished as it could be but it works fairly well
* You can use a custom HTTP client by <a href="backwater_http_request.html">encoding</a> and <a href="backwater_http_response.html">decoding</a> requests directly</p>

<p>Defaults, limits and thresholds:
* The default client connect timeout is 8s
* The default client receive timeout is 5s
* The compression threshold for encoded arguments and return values is 300 byte
* The maximum request and response body size is 8 MiB (whether compressed or uncompressed)
* Unsafe arguments and return values are not decoded by default
* Remote exceptions are returned as errors by default
* Remote exception stacktraces are returned by default</p>

<p>Security concerns:
* Replay attacks can't be prevented when using HTTP over untrusted networks
* Atom (non-)existence can be inferred by an authenticated attacker when the service is configured to reject unsafe terms (which happens by default)</p>

<p>To do:
* Polishing the rebar3 plugin code and funcionality
* Supporting generation of code wrappers under Elixir / Mix</p>

<p>Some more examples are under 'examples/'; for all possible configuration options, check the <a href="#modules">function reference</a>.</p>


<p><a name="examples"></a></p>


<hr>
<h3><a name="Example_1_-_Remote_'string'_module_and_client_code_generation_(Erlang)">Example 1 - Remote 'string' module and client code generation (Erlang)</a></h3>

<h4><a name="1.1._Configure_dependencies_and_the_rebar3_plugin">1.1. Configure dependencies and the rebar3 plugin</a></h4>
<pre lang="erlang">
% rebar.config
{backwater_gen,
 [{client_ref, example1},
  {target, {stdlib, string, [{exports,all}]}}]}.

{deps, [{backwater, "1.0.0"}]}.
{plugins, [{backwater, "1.0.0"}]}.
</pre>

<h4><a name="1.2._Generate_the_wrapper_code">1.2. Generate the wrapper code</a></h4>
<pre>
$ rebar3 backwater generate
# "src/rpc/rpc_string.erl" will be created
</pre>

<h4><a name="1.3._Generate_unique_secret">1.3. Generate unique secret</a></h4>
<pre lang="erlang">
Secret = crypto:strong_rand_bytes(32).
</pre>

<h4><a name="1.4._Start_server">1.4. Start server</a></h4>
<pre lang="erlang">
% Place this where appropriate e.g. on application start/2 callback
{ok, _Pid} =
    backwater_server:start_clear(
        example1,
        #{ secret =&gt; Secret,
           exposed_modules =&gt; [{string, [{exports,all}]] },
        [{port, 8080}],
        #{}).
</pre>

<h4><a name="1.5._Start_client">1.5. Start client</a></h4>
<pre lang="erlang">
% Place this where appropriate e.g. on application start/2 callback
ok = backwater_client:start(
        example1,
        #{ endpoint =&gt; &lt;&lt;"http://127.0.0.1:8080/"&gt;&gt;,
           secret =&gt; Secret }).
</pre>

<h4><a name="1.6._Execute_remote_calls_using_the_generated_code">1.6. Execute remote calls using the generated code</a></h4>
<pre lang="erlang">
{ok, 5} = rpc_string:length("hello"),
{ok, {3.14, ""}} = rpc_string:to_float("3.14").
</pre>


<hr>
<h3><a name="Example_2_-_A_basic_remote_calculator_using_Kernel_functions_(Elixir)">Example 2 - A basic remote calculator using Kernel functions (Elixir)</a></h3>

<h4><a name="2.1._Add_backwater_dependency_to_Mix">2.1. Add backwater dependency to Mix</a></h4>
<pre lang="elixir">
#mix.exs
# [...]
  defp deps do
    [{:backwater, "-&gt; 1.0"}]
  end
# [...]
</pre>

<h4><a name="2.2._Generate_unique_secret">2.2. Generate unique secret</a></h4>
<pre lang="elixir">
secret = :crypto.strong_rand_bytes(32)
</pre>

<h4><a name="2.3._Start_server">2.3. Start server</a></h4>
<pre lang="elixir">
{:ok, _pid} =
    :backwater_server.start_clear(
        :example2,
        %{ :secret =&gt; secret,
           :exposed_modules =&gt; [{Kernel, [{:exports, [:+, :-, :*, :/]}]}] },
        [{:port, 8080}],
        %{})
</pre>

<h4><a name="2.4_Start_client">2.4 Start client</a></h4>
<pre lang="elixir">
:ok = backwater_client.start(
        :example2,
        %{ :endpoint =&gt; "http://127.0.0.1:8080/",
           :secret =&gt; secret })
</pre>

<h4><a name="2.5_Execute_remote_calls">2.5 Execute remote calls</a></h4>
<pre lang="elixir">
{:ok, 5}   = :backwater_client.call(:example2, Kernel, :+, [3, 2])
{:ok, 1}   = :backwater_client.call(:example2, Kernel, :-, [3, 2])
{:ok, 6}   = :backwater_client.call(:example2, Kernel, :*, [3, 2])
{:ok, 1.5} = :backwater_client.call(:example2, Kernel, :/, [3, 2])
</pre>


<hr>
<h3><a name="Example_3_-_Exposure_of_a_module_using_custom_attributes_(Erlang)">Example 3 - Exposure of a module using custom attributes (Erlang)</a></h3>

<h4><a name="3.1._Add_backwater_dependency_to_rebar3">3.1. Add backwater dependency to rebar3</a></h4>
<pre lang="erlang">
% rebar.config
{deps, [{backwater, "1.0.0"}]}.
</pre>

<h4><a name="3.2._Add_custom_attributes_to_module_within_your_application">3.2. Add custom attributes to module within your application</a></h4>
<pre lang="erlang">
% foobar.erl
-module(foobar)
-export([hello/0, increment/1]).

% The custom export attribute
-backwater_export({hello,0}).
-backwater_export({increment,1}).

hello() -&gt; world.

increment(Number) -&gt; Number + 3.
</pre>

<h4><a name="3.3._Generate_unique_secret">3.3. Generate unique secret</a></h4>
<pre lang="erlang">
Secret = crypto:strong_rand_bytes(32).
</pre>

<h4><a name="3.4._Start_server">3.4. Start server</a></h4>
<pre lang="erlang">
% Place this where appropriate e.g. on application start/2 callback
{ok, _Pid} =
    backwater_server:start_clear(
        example3,
        #{ secret =&gt; Secret,
           exposed_modules =&gt; [foobar] }, % function exposure is determined by attributes
        [{port, 8080}],
        #{}).
</pre>

<h4><a name="3.5._Start_client">3.5. Start client</a></h4>
<pre lang="erlang">
% Place this where appropriate e.g. on application start/2 callback
ok = backwater_client:start(
        example3,
        #{ endpoint =&gt; &lt;&lt;"http://127.0.0.1:8080/"&gt;&gt;,
           secret =&gt; Secret }).
</pre>

<h4><a name="3.6._Execute_remote_calls">3.6. Execute remote calls</a></h4>
<pre lang="erlang">
{ok, world} = backwater_client:call(example3, foobar, hello, []),
{ok, 43} = backwater_client:call(example3, foobar, increment, [42]).
</pre>


<hr>
<h3><a name="Example_4_-_Exposure_of_a_module_using_export_function_(Elixir)">Example 4 - Exposure of a module using export function (Elixir)</a></h3>

<h4><a name="4.1._Add_backwater_dependency_to_Mix">4.1. Add backwater dependency to Mix</a></h4>
<pre lang="elixir">
#mix.exs
# [...]
  defp deps do
    [{:backwater, "-&gt; 1.0"}]
  end
# [...]
</pre>

<h4><a name="4.2._Add_custom_export_function_to_module_within_your_application">4.2. Add custom export function to module within your application</a></h4>
<pre lang="elixir">
# foobar.ex
defmodule Foobar do
  def backwater_export do
    [{:hello,0},
     {:increment,1}]
  end

  def hello do
    :world
  end

  def increment(number) do
    number + 1
  end
end
</pre>

<h4><a name="4.3._Generate_unique_secret">4.3. Generate unique secret</a></h4>
<pre lang="elixir">
secret = :crypto.strong_rand_bytes(32)
</pre>

<h4><a name="4.4._Start_server">4.4. Start server</a></h4>
<pre lang="elixir">
{:ok, _pid} =
    :backwater_server.start_clear(
        :example4,
        %{ :secret =&gt; secret,
           :exposed_modules =&gt; [Foobar] }, # function exposure is determined by custom export function
        [{:port, 8080}],
        %{})
</pre>

<h4><a name="4.5_Start_client">4.5 Start client</a></h4>
<pre lang="elixir">
:ok = :backwater_client.start(
        :example4,
        %{ :endpoint =&gt; "http://127.0.0.1:8080/",
           :secret =&gt; secret })
</pre>

<h4><a name="4.6_Execute_remote_calls">4.6 Execute remote calls</a></h4>
<pre lang="elixir">
{:ok, :world} = :backwater_client.call(example4, Foobar, :hello, [])
{:ok, 43} = :backwater_client.call(example4, Foobar, :increment, [42])
</pre>

<hr>
<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Aug 28 2017, 00:33:48.</i></p>
</body>
</html>
